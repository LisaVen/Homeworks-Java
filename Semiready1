
public class Account {
    private final long id;
    private final TransactionManager transactionManager;
    private final Entries entries;

    public Account(long id, TransactionManager transactionManager) {
        this.id = id;
        this.transactionManager = transactionManager;
        this.entries = new Entries();
    }

    /**
     * Withdraws money from account. <b>Should use TransactionManager to manage transactions</b>
     *
     * @param amount amount of money to withdraw
     * @return true
     * if amount &gt 0 and (currentBalance - amount) &ge 0,
     * otherwise returns false
     */
    public boolean withdraw(double amount, Account beneficiary) {
        // write your code here
        if (amount > 0 & (currentBalance - amount) >= 0){
            //delete amount from currentBalance whatever it is
            entries.addEntry(beneficiary);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Withdraws cash money from account. <b>Should use TransactionManager to manage transactions</b>
     *
     * @param amount amount of money to withdraw
     * @return true
     * if amount &gt 0 and (currentBalance - amount) &ge 0,
     * otherwise returns false
     */
    public boolean withdrawCash(double amount) {
        // write your code here
        if (amount > 0 & (currentBalance - amount) >= 0){
            //delete amount from currentBalance whatever it is
            //Should I use TransactionManager sure YES тут просто наличка отдельно шаритееее
            return true;
        } else {
            return false;
        }
    }

    /**
     * Adds cash money to account. <b>Should use TransactionManager to manage transactions</b>
     *
     * @param amount amount of money to add
     * @return true
     * if amount &gt 0,
     * otherwise returns false
     */
    public boolean addCash(double amount) {
        // write your code here
        if (amount > 0){
            //currentBalance += amount BABY USE TRANSACTIONMANAGER
            return true;
        } else {
            return false;
        }
    }

    /**
     * Adds money to account. <b>Should use TransactionManager to manage transactions</b>
     *
     * @param amount amount of money to add
     * @return true
     * if amount &gt 0,
     * otherwise returns false
     */
    public boolean add(double amount) {
        // write your code here
        if (amount > 0){
            //entries.addEntry(originator); //originator??????
            //currentBalance += amount BABY USE TRANSACTIONMANAGER
            return true;
        } else {
            return false;
        }
    }


    public Collection<Entry> history(LocalDate from, LocalDate to) {
        // write your code here
        //тут пока безнадега, но надо очень-очень разобраться
        //я так понимаю, тут выводятся все переводы деняк с одной даты по другую
        return history(from, to);
    }

    /**
     * Calculates balance on the accounting entries basis
     * @param date
     * @return balance
     */
    public double balanceOn(LocalDate date) {
        // write your code here
        //принимает дату, не выводит историю за этот день
       // history(date, date).containsAll();
        double balance = 100; //на основе истории вычислить баланс
        return balance;
    }

    /**
     * Finds the last transaction of the account and rollbacks it
     */
    public void rollbackLastTransaction() {
        // write your code here
        //удалить из коллекции и энтрис, видимо (еще проверю) последнюю транзакцию
    }
}

/**
 * The record of allocating the amount to the account
 * Amount can be either positive or negative depending on originator or beneficiary
 */
public class Entry {
    private final Account account;
    private final Transaction transaction;
    private final double amount;
    private final LocalDateTime time;

    public Entry(Account account, Transaction transaction, double amount, LocalDateTime time) {
        this.account = account;
        this.transaction = transaction;
        this.amount = amount;
        this.time = time;
    }
}

/**
 * Collection of entries for the account. Use it to save and get history of payments
 */
public class Entries {
    public Collection history;

    void addEntry(Entry entry) {
        // write your code here
        history.add(entry);
        //здесь будем, видимо, активировать коллекции, как только я разберусь, как их вообще кодить
    }

    Collection<Entry> from(LocalDate date) {
        // write your code here
        return from(date);
        //пока не до конца понятно, что с этим делать, буду разбираться.
    }

    Collection<Entry> betweenDates(LocalDate from, LocalDate to) {
        // write your code here
        return betweenDates(from, to);
        //тут, вероятно, требуется вывести все те входы, которые были в нужные даты.
    }

    Entry last() {
        // write your code here
        //возможно, мне пригодится то, что я удалила, из хистори достать последнюю итерацию.
        final Iterator itr = history.iterator();
        Object lastElement = itr.next();
        while(itr.hasNext()) {
            lastElement = itr.next();
        }
        return last();
    }
}

public class Transaction {
    private final long id;
    private final double amount;
    private final Account originator;
    private final Account beneficiary;
    private final boolean executed;
    private final boolean rolledBack;
//странное мероприятие с объявлениями переменных, но ладно.
    public Transaction(long id, double amount, Account originator, Account beneficiary, boolean executed, boolean rolledBack) {
        this.id = id;
        this.amount = amount;
        this.originator = originator;
        this.beneficiary = beneficiary;
        this.executed = executed;
        this.rolledBack = rolledBack;
    }

    /**
     * Adding entries to both accounts
     * @throws IllegalStateException when was already executed
     */
    public Transaction execute() {
        // write your code here
        if (originator == null){
            originator.add(entry); //на самом деле здесь добавить вход, я думаю, а там посмотрим.
        } else if (beneficiary == null){
            beneficiary.add(amount); //аналогично предыдущему
        } else {
            //throw IllegalStateException("It was already executed");
            return null; //сверху ошибка, надо почитать, как выкидывать исключения
        }
        return execute();
    }

    /**
     * Removes all entries of current transaction from originator and beneficiary
     * @throws IllegalStateException when was already rolled back
     */
    public Transaction rollback() {
        // write your code here
        if (originator == null){
            originator.add(-amount); //на самом деле здесь удалить вход, я думаю, а там посмотрим.
        } else if (beneficiary == null){
            beneficiary.add(-amount); //аналогично предыдущему
        } else {
            //throw IllegalStateException("It was already rolled back");
            return null; //сверху ошибка, надо почитать, как выкидывать исключения
        }
        return rollback();
    }
}


/**
 * Manages all transactions within the application
 */
public class TransactionManager {
    /**
     * Creates and stores transactions
     * @param amount
     * @param originator
     * @param beneficiary
     * @return created Transaction
     */
    public Transaction createTransaction(double amount,
                                         Account originator,
                                         Account beneficiary) {
        // write your code here
        Transaction transaction = createTransaction(amount, originator, beneficiary);
        return transaction;
    }

    public Collection<Transaction> findAllTransactionsByAccount(Account account) {
        // write your code here
        return findAllTransactionsByAccount(account);
        //короче не буду городить того, чего не знаю. Но она должна отслеживать все переводы я так поняла
    }


    public void rollbackTransaction(Transaction transaction) {
        // write your code here
        transaction.rollback();
        //отменяем соответственно так же как у энтрис
    }

    public void executeTransaction(Transaction transaction) {
        // write your code here
        transaction.execute();
        //добавляем как у энтрис
    }
}

public class AnalyticsManager {
    private final TransactionManager transactionManager;

    public AnalyticsManager(TransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public Account mostFrequentBeneficiaryOfAccount(Account account) {
        // write your code here
        //вывести самый часто встречающийся бенефишиари
    }

    public Collection<Transaction> topTenExpensivePurchases(Account account) {
        // write your code here
        //вывести 10 самых крупных переводов
    }
}
